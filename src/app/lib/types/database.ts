import { Document, Types } from 'mongoose';

/**
 * IUser describes the shape of a user document in the application.
 * It extends Mongoose's `Document` to include Mongoose-specific fields
 * while providing a typed surface for application code.
 */
export interface IUser extends Document {
  /** The user's primary wallet address (unique) */
  walletAddress: string;

  /** Optional display name */
  username?: string;

  /** Optional email */
  email?: string;

  /** User-specific settings */
  settings: {
    theme: string;
    notifications: boolean;
  };

  /** References to groups the user belongs to */
  groups: Types.ObjectId[];

  /** Creation timestamp */
  createdAt: Date;

  /** Last login timestamp */
  lastLogin: Date;
}

/**
 * IGroup describes the shape of a group document.
 */
export interface IGroup extends Document {
  /** Group name (should be unique within owner scope) */
  name: string;

  /** Optional description */
  description?: string;

  /** Wallet address of the creator */
  createdBy: string;

  /** Group members: can be stored as wallet addresses or objects with role metadata */
  members: Array<{
    walletAddress: string;
    role: 'admin' | 'member';
    joinedAt: Date;
  }>;

  /** Fine-grained permissions for the group */
  permissions: {
    canInvite: boolean;
    canPost: boolean;
  };

  /** Group-specific settings */
  settings: {
    isPublic: boolean;
    requiresApproval: boolean;
  };

  /** Creation timestamp */
  createdAt: Date;
}

/**
 * A small repository interface used by data access layers.
 *
 * T represents the document type the repository operates on. Methods
 * accept generic filter shapes (`Record<string, unknown>`) and return
 * typed results to keep usages ergonomic while avoiding `any`.
 */
export interface Repository<T> {
  /** Find a document by its string id (typically ObjectId.toString()) */
  findById(id: string): Promise<T | null>;

  /**
   * Find a single document by a field name and value.
   * `field` is constrained to keys of T (as strings) to help callers.
   */
  findByField(field: keyof T & string, value: unknown): Promise<T | null>;

  /** Find all documents matching an optional query object */
  findAll(query?: Record<string, unknown>): Promise<T[]>;

  /** Create a new document. Omit fields normally generated by the DB */
  create(data: Omit<T, 'id' | 'createdAt'>): Promise<T>;

  /** Update a document by id. Returns the updated document or null */
  update(id: string, data: Partial<T>): Promise<T | null>;

  /** Delete a document by id */
  delete(id: string): Promise<boolean>;

  /** Upsert a document matching the filter */
  upsert(filter: Record<string, unknown>, data: Partial<T>): Promise<T>;
}